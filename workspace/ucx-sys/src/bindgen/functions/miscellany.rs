// This file is part of rdma-core. It is subject to the license terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/rdma-core/master/COPYRIGHT. No part of rdma-core, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
// Copyright Â© 2016 The developers of rdma-core. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/rdma-core/master/COPYRIGHT.


extern "C"
{
	pub fn __sched_cpucount(arg1: usize, arg2: *const cpu_set_t) -> c_int;
	pub fn __ucs_async_poll_missed(async: *mut ucs_async_context_t);
	pub fn accept(arg1: c_int, arg2: *mut sockaddr, arg3: *mut socklen_t) -> c_int;
	pub fn accept4(arg1: c_int, arg2: *mut sockaddr, arg3: *mut socklen_t, arg4: c_int) -> c_int;
	pub fn asprintf(arg1: *mut *mut c_char, arg2: *const c_char, ...) -> c_int;
	pub fn bind(arg1: c_int, arg2: *const sockaddr, arg3: socklen_t) -> c_int;
	pub fn calloc(arg1: usize, arg2: usize) -> *mut c_void;
	pub fn clearerr(arg1: *mut FILE);
	pub fn clearerr_unlocked(arg1: *mut FILE);
	pub fn clone(arg1: Option<unsafe extern "C" fn(arg1: *mut c_void) -> c_int>, arg2: *mut c_void, arg3: c_int, arg4: *mut c_void, ...) -> c_int;
	pub fn connect(arg1: c_int, arg2: *const sockaddr, arg3: socklen_t) -> c_int;
	pub fn ctermid(arg1: *mut c_char) -> *mut c_char;
	pub fn cuserid(arg1: *mut c_char) -> *mut c_char;
	pub fn dprintf(arg1: c_int, arg2: *const c_char, ...) -> c_int;
	pub fn fclose(arg1: *mut FILE) -> c_int;
	pub fn fdopen(arg1: c_int, arg2: *const c_char) -> *mut FILE;
	pub fn feof(arg1: *mut FILE) -> c_int;
	pub fn feof_unlocked(arg1: *mut FILE) -> c_int;
	pub fn ferror(arg1: *mut FILE) -> c_int;
	pub fn ferror_unlocked(arg1: *mut FILE) -> c_int;
	pub fn fflush(arg1: *mut FILE) -> c_int;
	pub fn fflush_unlocked(arg1: *mut FILE) -> c_int;
	pub fn fgetc(arg1: *mut FILE) -> c_int;
	pub fn fgetc_unlocked(arg1: *mut FILE) -> c_int;
	pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut c_char;
	pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> c_int;
	pub fn fgets(arg1: *mut c_char, arg2: c_int, arg3: *mut FILE) -> *mut c_char;
	pub fn fgets_unlocked(arg1: *mut c_char, arg2: c_int, arg3: *mut FILE) -> *mut c_char;
	pub fn fileno(arg1: *mut FILE) -> c_int;
	pub fn fileno_unlocked(arg1: *mut FILE) -> c_int;
	pub fn flockfile(arg1: *mut FILE);
	pub fn fmemopen(arg1: *mut c_void, arg2: usize, arg3: *const c_char) -> *mut FILE;
	pub fn fopen(arg1: *const c_char, arg2: *const c_char) -> *mut FILE;
	pub fn fprintf(arg1: *mut FILE, arg2: *const c_char, ...) -> c_int;
	pub fn fputc(arg1: c_int, arg2: *mut FILE) -> c_int;
	pub fn fputc_unlocked(arg1: c_int, arg2: *mut FILE) -> c_int;
	pub fn fputs(arg1: *const c_char, arg2: *mut FILE) -> c_int;
	pub fn fputs_unlocked(arg1: *const c_char, arg2: *mut FILE) -> c_int;
	pub fn fread(arg1: *mut c_void, arg2: usize, arg3: usize, arg4: *mut FILE) -> usize;
	pub fn fread_unlocked(arg1: *mut c_void, arg2: usize, arg3: usize, arg4: *mut FILE) -> usize;
	pub fn free(arg1: *mut c_void);
	pub fn freopen(arg1: *const c_char, arg2: *const c_char, arg3: *mut FILE) -> *mut FILE;
	pub fn fscanf(arg1: *mut FILE, arg2: *const c_char, ...) -> c_int;
	pub fn fseek(arg1: *mut FILE, arg2: c_long, arg3: c_int) -> c_int;
	pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: c_int) -> c_int;
	pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> c_int;
	pub fn ftell(arg1: *mut FILE) -> c_long;
	pub fn ftello(arg1: *mut FILE) -> off_t;
	pub fn ftrylockfile(arg1: *mut FILE) -> c_int;
	pub fn funlockfile(arg1: *mut FILE);
	pub fn fwrite(arg1: *const c_void, arg2: usize, arg3: usize, arg4: *mut FILE) -> usize;
	pub fn fwrite_unlocked(arg1: *const c_void, arg2: usize, arg3: usize, arg4: *mut FILE) -> usize;
	pub fn getc(arg1: *mut FILE) -> c_int;
	pub fn getc_unlocked(arg1: *mut FILE) -> c_int;
	pub fn getchar() -> c_int;
	pub fn getchar_unlocked() -> c_int;
	pub fn getdelim(arg1: *mut *mut c_char, arg2: *mut usize, arg3: c_int, arg4: *mut FILE) -> isize;
	pub fn getline(arg1: *mut *mut c_char, arg2: *mut usize, arg3: *mut FILE) -> isize;
	pub fn getpeername(arg1: c_int, arg2: *mut sockaddr, arg3: *mut socklen_t) -> c_int;
	pub fn getsockname(arg1: c_int, arg2: *mut sockaddr, arg3: *mut socklen_t) -> c_int;
	pub fn getsockopt(arg1: c_int, arg2: c_int, arg3: c_int, arg4: *mut c_void, arg5: *mut socklen_t) -> c_int;
	pub fn getw(arg1: *mut FILE) -> c_int;
	pub fn listen(arg1: c_int, arg2: c_int) -> c_int;
	pub fn memcmp(arg1: *const c_void, arg2: *const c_void, arg3: usize) -> c_int;
	pub fn memcpy(arg1: *mut c_void, arg2: *const c_void, arg3: usize) -> *mut c_void;
	pub fn open_memstream(arg1: *mut *mut c_char, arg2: *mut usize) -> *mut FILE;
	pub fn pclose(arg1: *mut FILE) -> c_int;
	pub fn perror(arg1: *const c_char);
	pub fn popen(arg1: *const c_char, arg2: *const c_char) -> *mut FILE;
	pub fn printf(arg1: *const c_char, ...) -> c_int;
	pub fn pselect(arg1: c_int, arg2: *mut fd_set, arg3: *mut fd_set, arg4: *mut fd_set, arg5: *const timespec, arg6: *const sigset_t) -> c_int;
	pub fn putc(arg1: c_int, arg2: *mut FILE) -> c_int;
	pub fn putc_unlocked(arg1: c_int, arg2: *mut FILE) -> c_int;
	pub fn putchar(arg1: c_int) -> c_int;
	pub fn putchar_unlocked(arg1: c_int) -> c_int;
	pub fn puts(arg1: *const c_char) -> c_int;
	pub fn putw(arg1: c_int, arg2: *mut FILE) -> c_int;
	pub fn recv(arg1: c_int, arg2: *mut c_void, arg3: usize, arg4: c_int) -> isize;
	pub fn recvfrom(arg1: c_int, arg2: *mut c_void, arg3: usize, arg4: c_int, arg5: *mut sockaddr, arg6: *mut socklen_t) -> isize;
	pub fn recvmmsg(arg1: c_int, arg2: *mut mmsghdr, arg3: c_uint, arg4: c_uint, arg5: *mut timespec) -> c_int;
	pub fn recvmsg(arg1: c_int, arg2: *mut msghdr, arg3: c_int) -> isize;
	pub fn remove(arg1: *const c_char) -> c_int;
	pub fn rename(arg1: *const c_char, arg2: *const c_char) -> c_int;
	pub fn renameat(arg1: c_int, arg2: *const c_char, arg3: c_int, arg4: *const c_char) -> c_int;
	pub fn rewind(arg1: *mut FILE);
	pub fn scanf(arg1: *const c_char, ...) -> c_int;
	pub fn sched_get_priority_max(arg1: c_int) -> c_int;
	pub fn sched_get_priority_min(arg1: c_int) -> c_int;
	pub fn sched_getaffinity(arg1: pid_t, arg2: usize, arg3: *mut cpu_set_t) -> c_int;
	pub fn sched_getcpu() -> c_int;
	pub fn sched_getparam(arg1: pid_t, arg2: *mut sched_param) -> c_int;
	pub fn sched_getscheduler(arg1: pid_t) -> c_int;
	pub fn sched_rr_get_interval(arg1: pid_t, arg2: *mut timespec) -> c_int;
	pub fn sched_setaffinity(arg1: pid_t, arg2: usize, arg3: *const cpu_set_t) -> c_int;
	pub fn sched_setparam(arg1: pid_t, arg2: *const sched_param) -> c_int;
	pub fn sched_setscheduler(arg1: pid_t, arg2: c_int, arg3: *const sched_param) -> c_int;
	pub fn sched_yield() -> c_int;
	pub fn select(arg1: c_int, arg2: *mut fd_set, arg3: *mut fd_set, arg4: *mut fd_set, arg5: *mut timeval) -> c_int;
	pub fn send(arg1: c_int, arg2: *const c_void, arg3: usize, arg4: c_int) -> isize;
	pub fn sendmmsg(arg1: c_int, arg2: *mut mmsghdr, arg3: c_uint, arg4: c_uint) -> c_int;
	pub fn sendmsg(arg1: c_int, arg2: *const msghdr, arg3: c_int) -> isize;
	pub fn sendto(arg1: c_int, arg2: *const c_void, arg3: usize, arg4: c_int, arg5: *const sockaddr, arg6: socklen_t) -> isize;
	pub fn setbuf(arg1: *mut FILE, arg2: *mut c_char);
	pub fn setbuffer(arg1: *mut FILE, arg2: *mut c_char, arg3: usize);
	pub fn setlinebuf(arg1: *mut FILE);
	pub fn setns(arg1: c_int, arg2: c_int) -> c_int;
	pub fn setsockopt(arg1: c_int, arg2: c_int, arg3: c_int, arg4: *const c_void, arg5: socklen_t) -> c_int;
	pub fn setvbuf(arg1: *mut FILE, arg2: *mut c_char, arg3: c_int, arg4: usize) -> c_int;
	pub fn shutdown(arg1: c_int, arg2: c_int) -> c_int;
	pub fn snprintf(arg1: *mut c_char, arg2: usize, arg3: *const c_char, ...) -> c_int;
	pub fn sockatmark(arg1: c_int) -> c_int;
	pub fn socket(arg1: c_int, arg2: c_int, arg3: c_int) -> c_int;
	pub fn socketpair(arg1: c_int, arg2: c_int, arg3: c_int, arg4: *mut c_int) -> c_int;
	pub fn sprintf(arg1: *mut c_char, arg2: *const c_char, ...) -> c_int;
	pub fn sscanf(arg1: *const c_char, arg2: *const c_char, ...) -> c_int;
	pub fn tempnam(arg1: *const c_char, arg2: *const c_char) -> *mut c_char;
	pub fn tmpfile() -> *mut FILE;
	pub fn tmpnam(arg1: *mut c_char) -> *mut c_char;
	pub fn ucs_async_add_timer(mode: ucs_async_mode_t, interval: ucs_time_t, cb: ucs_async_event_cb_t, arg: *mut c_void, async: *mut ucs_async_context_t, timer_id_p: *mut c_int) -> ucs_status_t;
	pub fn ucs_async_context_create(mode: ucs_async_mode_t, async_p: *mut *mut ucs_async_context_t) -> ucs_status_t;
	pub fn ucs_async_context_destroy(async: *mut ucs_async_context_t);
	pub fn ucs_async_poll(async: *mut ucs_async_context_t);
	pub fn ucs_async_remove_handler(id: c_int, sync: c_int) -> ucs_status_t;
	pub fn ucs_async_set_event_handler(mode: ucs_async_mode_t, event_fd: c_int, events: c_int, cb: ucs_async_event_cb_t, arg: *mut c_void, async: *mut ucs_async_context_t) -> ucs_status_t;
	pub fn ucs_callbackq_add(cbq: *mut ucs_callbackq_t, cb: ucs_callback_t, arg: *mut c_void);
	pub fn ucs_callbackq_add_safe(cbq: *mut ucs_callbackq_t, cb: ucs_callback_t, arg: *mut c_void) -> ucs_status_t;
	pub fn ucs_callbackq_add_slow_path(cbq: *mut ucs_callbackq_t, elem: *mut ucs_callbackq_slow_elem_t);
	pub fn ucs_callbackq_cleanup(cbq: *mut ucs_callbackq_t);
	pub fn ucs_callbackq_init(cbq: *mut ucs_callbackq_t, size: usize, async: *mut ucs_async_context_t) -> ucs_status_t;
	pub fn ucs_callbackq_purge_slow_path(cbq: *mut ucs_callbackq_t, cb: ucs_callback_slow_t, list: *mut ucs_list_link_t);
	pub fn ucs_callbackq_remove(cbq: *mut ucs_callbackq_t, cb: ucs_callback_t, arg: *mut c_void) -> ucs_status_t;
	pub fn ucs_callbackq_remove_all(cbq: *mut ucs_callbackq_t, cb: ucs_callback_t, arg: *mut c_void);
	pub fn ucs_callbackq_remove_safe(cbq: *mut ucs_callbackq_t, cb: ucs_callback_t, arg: *mut c_void) -> ucs_status_t;
	pub fn ucs_callbackq_remove_slow_path(cbq: *mut ucs_callbackq_t, elem: *mut ucs_callbackq_slow_elem_t);
	pub fn ucs_stats_get_root() -> *mut ucs_stats_node_t;
	pub fn ucs_status_string(status: ucs_status_t) -> *const c_char;
	pub fn uct_config_modify(config: *mut c_void, name: *const c_char, value: *const c_char) -> ucs_status_t;
	pub fn uct_config_print(config: *const c_void, stream: *mut FILE, title: *const c_char, print_flags: ucs_config_print_flags_t);
	pub fn uct_config_release(config: *mut c_void);
	pub fn uct_ep_check(ep: uct_ep_h, flags: c_uint, comp: *mut uct_completion_t) -> ucs_status_t;
	pub fn uct_ep_connect_to_ep(ep: uct_ep_h, dev_addr: *const uct_device_addr_t, ep_addr: *const uct_ep_addr_t) -> ucs_status_t;
	pub fn uct_ep_create(iface: uct_iface_h, ep_p: *mut uct_ep_h) -> ucs_status_t;
	pub fn uct_ep_create_connected(iface: uct_iface_h, dev_addr: *const uct_device_addr_t, iface_addr: *const uct_iface_addr_t, ep_p: *mut uct_ep_h) -> ucs_status_t;
	pub fn uct_ep_destroy(ep: uct_ep_h);
	pub fn uct_ep_get_address(ep: uct_ep_h, addr: *mut uct_ep_addr_t) -> ucs_status_t;
	pub fn uct_iface_close(iface: uct_iface_h);
	pub fn uct_iface_config_read(tl_name: *const c_char, env_prefix: *const c_char, filename: *const c_char, config_p: *mut *mut uct_iface_config_t) -> ucs_status_t;
	pub fn uct_iface_get_address(iface: uct_iface_h, addr: *mut uct_iface_addr_t) -> ucs_status_t;
	pub fn uct_iface_get_device_address(iface: uct_iface_h, addr: *mut uct_device_addr_t) -> ucs_status_t;
	pub fn uct_iface_is_reachable(iface: uct_iface_h, dev_addr: *const uct_device_addr_t, iface_addr: *const uct_iface_addr_t) -> c_int;
	pub fn uct_iface_mem_alloc(iface: uct_iface_h, length: usize, flags: c_uint, name: *const c_char, mem: *mut uct_allocated_memory_t) -> ucs_status_t;
	pub fn uct_iface_mem_free(mem: *const uct_allocated_memory_t);
	pub fn uct_iface_open(md: uct_md_h, worker: uct_worker_h, params: *const uct_iface_params_t, config: *const uct_iface_config_t, iface_p: *mut uct_iface_h) -> ucs_status_t;
	pub fn uct_iface_query(iface: uct_iface_h, iface_attr: *mut uct_iface_attr_t) -> ucs_status_t;
	pub fn uct_iface_set_am_handler(iface: uct_iface_h, id: u8, cb: uct_am_callback_t, arg: *mut c_void, flags: u32) -> ucs_status_t;
	pub fn uct_iface_set_am_tracer(iface: uct_iface_h, tracer: uct_am_tracer_t, arg: *mut c_void) -> ucs_status_t;
	pub fn uct_md_close(md: uct_md_h);
	pub fn uct_md_config_read(name: *const c_char, env_prefix: *const c_char, filename: *const c_char, config_p: *mut *mut uct_md_config_t) -> ucs_status_t;
	pub fn uct_md_mem_advise(md: uct_md_h, memh: uct_mem_h, addr: *mut c_void, length: usize, advice: uct_mem_advice_t) -> ucs_status_t;
	pub fn uct_md_mem_alloc(md: uct_md_h, length_p: *mut usize, address_p: *mut *mut c_void, flags: c_uint, name: *const c_char, memh_p: *mut uct_mem_h) -> ucs_status_t;
	pub fn uct_md_mem_dereg(md: uct_md_h, memh: uct_mem_h) -> ucs_status_t;
	pub fn uct_md_mem_free(md: uct_md_h, memh: uct_mem_h) -> ucs_status_t;
	pub fn uct_md_mem_reg(md: uct_md_h, address: *mut c_void, length: usize, flags: c_uint, memh_p: *mut uct_mem_h) -> ucs_status_t;
	pub fn uct_md_mkey_pack(md: uct_md_h, memh: uct_mem_h, rkey_buffer: *mut c_void) -> ucs_status_t;
	pub fn uct_md_open(md_name: *const c_char, config: *const uct_md_config_t, md_p: *mut uct_md_h) -> ucs_status_t;
	pub fn uct_md_query(md: uct_md_h, md_attr: *mut uct_md_attr_t) -> ucs_status_t;
	pub fn uct_md_query_tl_resources(md: uct_md_h, resources_p: *mut *mut uct_tl_resource_desc_t, num_resources_p: *mut c_uint) -> ucs_status_t;
	pub fn uct_mem_alloc(addr: *mut c_void, min_length: usize, flags: c_uint, methods: *mut uct_alloc_method_t, num_methods: c_uint, mds: *mut uct_md_h, num_mds: c_uint, name: *const c_char, mem: *mut uct_allocated_memory_t) -> ucs_status_t;
	pub fn uct_mem_free(mem: *const uct_allocated_memory_t) -> ucs_status_t;
	pub fn uct_query_md_resources(resources_p: *mut *mut uct_md_resource_desc_t, num_resources_p: *mut c_uint) -> ucs_status_t;
	pub fn uct_release_md_resource_list(resources: *mut uct_md_resource_desc_t);
	pub fn uct_release_tl_resource_list(resources: *mut uct_tl_resource_desc_t);
	pub fn uct_rkey_release(rkey_ob: *const uct_rkey_bundle_t) -> ucs_status_t;
	pub fn uct_rkey_unpack(rkey_buffer: *const c_void, rkey_ob: *mut uct_rkey_bundle_t) -> ucs_status_t;
	pub fn uct_wakeup_close(wakeup: uct_wakeup_h);
	pub fn uct_wakeup_efd_arm(wakeup: uct_wakeup_h) -> ucs_status_t;
	pub fn uct_wakeup_efd_get(wakeup: uct_wakeup_h, fd_p: *mut c_int) -> ucs_status_t;
	pub fn uct_wakeup_open(iface: uct_iface_h, events: c_uint, wakeup_p: *mut uct_wakeup_h) -> ucs_status_t;
	pub fn uct_wakeup_signal(wakeup: uct_wakeup_h) -> ucs_status_t;
	pub fn uct_wakeup_wait(wakeup: uct_wakeup_h) -> ucs_status_t;
	pub fn uct_worker_create(async: *mut ucs_async_context_t, thread_mode: ucs_thread_mode_t, worker_p: *mut uct_worker_h) -> ucs_status_t;
	pub fn uct_worker_destroy(worker: uct_worker_h);
	pub fn uct_worker_progress(worker: uct_worker_h);
	pub fn uct_worker_progress_register(worker: uct_worker_h, func: ucs_callback_t, arg: *mut c_void);
	pub fn uct_worker_progress_unregister(worker: uct_worker_h, func: ucs_callback_t, arg: *mut c_void);
	pub fn uct_worker_slowpath_progress_register(worker: uct_worker_h, elem: *mut ucs_callbackq_slow_elem_t);
	pub fn uct_worker_slowpath_progress_unregister(worker: uct_worker_h, elem: *mut ucs_callbackq_slow_elem_t);
	pub fn ungetc(arg1: c_int, arg2: *mut FILE) -> c_int;
	pub fn unshare(arg1: c_int) -> c_int;
	pub fn vasprintf(arg1: *mut *mut c_char, arg2: *const c_char, arg3: *mut __va_list_tag) -> c_int;
	pub fn vdprintf(arg1: c_int, arg2: *const c_char, arg3: *mut __va_list_tag) -> c_int;
	pub fn vfprintf(arg1: *mut FILE, arg2: *const c_char, arg3: *mut __va_list_tag) -> c_int;
	pub fn vfscanf(arg1: *mut FILE, arg2: *const c_char, arg3: *mut __va_list_tag) -> c_int;
	pub fn vprintf(arg1: *const c_char, arg2: *mut __va_list_tag) -> c_int;
	pub fn vscanf(arg1: *const c_char, arg2: *mut __va_list_tag) -> c_int;
	pub fn vsnprintf(arg1: *mut c_char, arg2: usize, arg3: *const c_char, arg4: *mut __va_list_tag) -> c_int;
	pub fn vsprintf(arg1: *mut c_char, arg2: *const c_char, arg3: *mut __va_list_tag) -> c_int;
	pub fn vsscanf(arg1: *const c_char, arg2: *const c_char, arg3: *mut __va_list_tag) -> c_int;
}
